# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15DXAiJ3xcSY9toSztDvOnqZSb_vmziXt
"""

import pandas as pd
import numpy as np
import math
import networkx as nx
import os
import heapq


#Se importa el archivo csv con los datos de los aeropuertos
#current_dir = os.path.dirname(os.path.abspath(__file__))
#file_path = os.path.join(current_dir, 'flights_final.csv')
datos = pd.read_csv("flights_final.csv")
datos= datos.drop_duplicates()



#Función para calcular la distancia entre dos puntos en la superficie de la Tierra
def haversine(lat1, lon1, lat2, lon2):
    R = 6371.0
    # Hallamos los diferenciales
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Fórmula de Haversine
    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c

    return distance

#Se extraen los datos de los codigos de origen y destino de los aeropuertos en listas
codigos_origen=datos['Source Airport Code']
codigos_destino=datos['Destination Airport Code']
codigos_origen = list(codigos_origen)
codigos_destino = list(codigos_destino)


#Se eliminan los duplicados de los codigos de origen y destino y se crea una sola lista con los vertices del grafo
vertices =[]
if (len(codigos_origen) == len(codigos_destino)):
    for i in range(len(codigos_origen)):
        if codigos_origen[i] not in vertices:
            vertices.append(codigos_origen[i])
        if codigos_destino[i] not in vertices:
            vertices.append(codigos_destino[i])


    
def crear_grafo(codigos_origen, codigos_destino, vertices):
    # Crear un nuevo grafo vacío usando NetworkX
    G = nx.Graph()
    
    # Añadir nodos al grafo con información adicional como latitud, longitud, nombre, ciudad y país
    for idx, row in datos.iterrows():
        G.add_node(
            row['Source Airport Code'],  # Código del aeropuerto como identificador del nodo
            latitude=row['Source Airport Latitude'],  # Latitud del aeropuerto
            longitude=row['Source Airport Longitude'],  # Longitud del aeropuerto
            name=row['Source Airport Name'],  # Nombre del aeropuerto
            city=row['Source Airport City'],  # Ciudad del aeropuerto
            country=row['Source Airport Country']  # País del aeropuerto
        )

    # Inicializar listas para almacenar las aristas y los pesos de las rutas
    aristas = [] 
    pesos = []

    # Recorrer las listas de códigos de aeropuertos de origen y destino para añadir las aristas
    for j in range(len(codigos_origen)):
        # Verificar si ya existe una arista entre los nodos; si existe, saltar al siguiente
        if G.has_edge(codigos_origen[j], codigos_destino[j]):
            continue
        else:
            # Obtener las coordenadas del aeropuerto de origen
            lat1 = datos['Source Airport Latitude'].iloc[j]
            lon1 = datos['Source Airport Longitude'].iloc[j]
            # Obtener las coordenadas del aeropuerto de destino
            lat2 = datos['Destination Airport Latitude'].iloc[j]
            lon2 = datos['Destination Airport Longitude'].iloc[j]

            # Calcular la distancia entre los dos aeropuertos usando la fórmula de Haversine
            peso = haversine(math.radians(lat1), math.radians(lon1), math.radians(lat2), math.radians(lon2))
            # Añadir el peso (distancia) a la lista de pesos
            pesos.append(peso)
            # Añadir la arista al grafo con el peso calculado
            G.add_edge(codigos_origen[j], codigos_destino[j], weight=peso)
            # Registrar la arista en la lista de aristas
            aristas.append((codigos_origen[j], codigos_destino[j]))
    
    # Devolver el grafo creado, la lista de aristas y la lista de pesos
    return G, aristas, pesos


import folium

def mapa_camino(grafo, camino):
    # Verifica si la lista de camino está vacía; si lo está, muestra un mensaje y termina la función
    if not camino:
        print("No hay camino para mostrar en el mapa.")
        return

    # Extrae las latitudes y longitudes de los nodos en el camino
    latitudes = [grafo.nodes[codigo]['latitude'] for codigo in camino]
    longitudes = [grafo.nodes[codigo]['longitude'] for codigo in camino]

    # Crea un mapa centrado en el primer aeropuerto del camino, con un nivel de zoom inicial
    mapa = folium.Map(location=[latitudes[0], longitudes[0]], zoom_start=5)

    # Recorre los códigos de aeropuerto en el camino para añadir marcadores al mapa
    for i, codigo in enumerate(camino):
        # Extrae la información del nodo (aeropuerto) actual
        datos = grafo.nodes[codigo]
        
        # Añade un marcador para cada aeropuerto con información adicional en el popup
        folium.Marker(
            location=[datos['latitude'], datos['longitude']],
            popup=f"{datos['name']} ({codigo})<br>Ciudad: {datos['city']}<br>País: {datos['country']}",
            icon=folium.Icon(color='blue', icon='plane', prefix='fa')  # Ícono de marcador personalizado
        ).add_to(mapa)

        # Si no es el último nodo, dibuja una línea hacia el siguiente aeropuerto en el camino
        if i < len(camino) - 1:
            next_lat = grafo.nodes[camino[i + 1]]['latitude']
            next_lon = grafo.nodes[camino[i + 1]]['longitude']
            # Añade una línea azul que conecta el aeropuerto actual con el siguiente
            folium.PolyLine(
                locations=[(datos['latitude'], datos['longitude']), (next_lat, next_lon)],
                color='red',
                weight=2.5,  # Grosor de la línea
                opacity=1    # Opacidad de la línea
            ).add_to(mapa)

    # Guarda el mapa en un archivo HTML para visualizarlo en un navegador
    mapa.save('mapa_camino.html')
    print("Mapa guardado como 'mapa_camino.html'.")



#El siguiente bloque de código es para calcular el bosque de expansión mínima del grafo creado, teniendo en cuenta que el grafo es disconexo
# Definición de la clase Union-Find
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])  # Compresión de caminos
        return self.parent[u]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            # Unión por rango
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1
            return True
        return False

# Función para extraer el bosque de expansión mínima y calcular el peso total
def bosque_expansion_minima_manual(G):
    # Obtener todas las aristas y sus pesos
    aristas = []
    for u, v, data in G.edges(data=True):
        aristas.append((data['weight'], u, v))

    # Ordenar las aristas por peso
    aristas.sort()

    # Inicializar Union-Find
    uf = UnionFind(len(G.nodes()))
    componentes = list(nx.connected_components(G))  # Obtener las componentes
    bosques = nx.Graph()  # Declarar bosques como un grafo
    peso_total = 0

    # Mapa de nodos a índices
    nodo_a_indice = {nodo: idx for idx, nodo in enumerate(G.nodes())}

    # Iterar sobre las aristas ordenadas
    numedges=0
    for peso, u, v in aristas:
        idx_u = nodo_a_indice[u]
        idx_v = nodo_a_indice[v]

        if uf.union(idx_u, idx_v):  # Si no forma un ciclo
            bosques.add_edge(u, v, weight=peso)  # Agregar al grafo de bosques
            peso_total += peso
            numedges+=1

    return bosques, peso_total, numedges
#Fin del bloque del arbol de expansion minima del grafo


#kr = dict(zip([tuple(arista) for arista in aristas], pesos))



def mostrar_info_aeropuerto(codigo_aeropuerto):
    aeropuerto = datos[datos['Source Airport Code'] == codigo_aeropuerto]
    if not aeropuerto.empty:
        info = aeropuerto.iloc[0]
        print(f"Código: {info['Source Airport Code']}")
        print(f"Nombre: {info['Source Airport Name']}")
        print(f"Ciudad: {info['Source Airport City']}")
        print(f"País: {info['Source Airport Country']}")
        print(f"Latitud: {info['Source Airport Latitude']}")
        print(f"Longitud: {info['Source Airport Longitude']}")
    else:
        print(f"No se encontró el aeropuerto con código {codigo_aeropuerto}.")


def mostrar_informacion_aeropuerto(codigo, datos):
    aeropuerto = datos[datos['Source Airport Code'] == codigo].iloc[0]
    print(f"Código: {aeropuerto['Source Airport Code']}")
    print(f"Nombre: {aeropuerto['Source Airport Name']}")
    print(f"Ciudad: {aeropuerto['Source Airport City']}")
    print(f"País: {aeropuerto['Source Airport Country']}")
    print(f"Latitud: {aeropuerto['Source Airport Latitude']}")
    print(f"Longitud: {aeropuerto['Source Airport Longitude']}")
    print("-" * 30)

# Algoritmo de Dijkstra corregido para evitar el error
def dijkstra_manual(G, origen):
    # Inicializar distancias y predecesores
    distancias = {nodo: float('inf') for nodo in G.nodes()}
    distancias[origen] = 0  # La distancia del origen a sí mismo es 0
    predecesores = {nodo: None for nodo in G.nodes()}

    # Inicializar la cola de prioridad (min-heap)
    heap = []
    heapq.heappush(heap, (0, origen))  # (distancia, nodo)

    procesados = set()

    while heap:
        # Obtener el nodo con la menor distancia
        distancia_actual, nodo_actual = heapq.heappop(heap)

        if nodo_actual in procesados:
            continue
        procesados.add(nodo_actual)

        # Relajación de las aristas
        for vecino, datos in G[nodo_actual].items():
            peso_arista = datos['weight']
            distancia_nueva = distancia_actual + peso_arista

            if distancia_nueva < distancias[vecino]:
                distancias[vecino] = distancia_nueva
                predecesores[vecino] = nodo_actual
                heapq.heappush(heap, (distancia_nueva, vecino))

    return distancias, predecesores


# Función para calcular los 10 caminos más largos usando Dijkstra
def aeropuertos_mas_lejanos(G, codigo_aeropuerto, datos):
    # Dijkstra para obtener las distancias desde el aeropuerto dado
    distancias, _ = dijkstra_manual(G, codigo_aeropuerto)

    distancias_filtradas = {codigo: dist for codigo, dist in distancias.items() if dist != float('inf')}
    # Ordenar las distancias de mayor a menor y seleccionar los 10 más largos
    distancias_ordenadas = sorted(distancias_filtradas.items(), key=lambda item: item[1], reverse=True)[:10]

    # Mostrar información de los 10 aeropuertos más lejanos
    print("Los 10 aeropuertos más lejanos:")
    for codigo, distancia in distancias_ordenadas:
        aeropuerto = datos[datos['Source Airport Code'] == codigo].iloc[0]
        print(f"Código: {aeropuerto['Source Airport Code']}")
        print(f"Nombre: {aeropuerto['Source Airport Name']}")
        print(f"Ciudad: {aeropuerto['Source Airport City']}")
        print(f"País: {aeropuerto['Source Airport Country']}")
        print(f"Latitud: {aeropuerto['Source Airport Latitude']}")
        print(f"Longitud: {aeropuerto['Source Airport Longitude']}")
        print(f"Distancia: {distancia:.2f} km\n")



# Función de Dijkstra para hallar la distancia mínima entre dos nodos
def dijkstra_minima_distancia_entre_dos(G, origen, destino):
    # Inicializar distancias y predecesores
    distancias = {nodo: math.inf for nodo in G.nodes()}
    distancias[origen] = 0  # La distancia del origen a sí mismo es 0
    predecesores = {nodo: None for nodo in G.nodes()}

    # Cola de prioridad (min-heap)
    heap = [(0, origen)]  # (distancia, nodo)
    procesados = set()

    while heap:
        distancia_actual, nodo_actual = heapq.heappop(heap)

        if nodo_actual == destino:
            # Si llegamos al destino, devolvemos la distancia mínima encontrada
            return distancias[destino], predecesores

        if nodo_actual in procesados:
            continue
        procesados.add(nodo_actual)

        # Relajación de las aristas
        for vecino, datos in G[nodo_actual].items():
            peso_arista = datos['weight']
            distancia_nueva = distancia_actual + peso_arista

            if distancia_nueva < distancias[vecino]:
                distancias[vecino] = distancia_nueva
                predecesores[vecino] = nodo_actual
                heapq.heappush(heap, (distancia_nueva, vecino))

    # Si terminamos el bucle y no encontramos el destino, no hay camino
    return math.inf, predecesores

# Función para reconstruir el camino desde el nodo origen al destino
def reconstruir_camino(predecesores, origen, destino):
    camino = []
    nodo_actual = destino

    while nodo_actual is not None:
        camino.insert(0, nodo_actual)
        nodo_actual = predecesores[nodo_actual]

    # Si el primer nodo del camino no es el origen, no hay camino válido
    if camino[0] != origen:
        return []

    return camino


#Funcion para validar un codigo ingresado y contrastarlo con la posibilidad de que este en la lista de vertices y en el csv
def validar_codigo(codigo):
    if codigo in vertices and (codigo in codigos_origen or codigo in codigos_destino):
        return True
    else:
        print("El codigo ingresado no se encuentra en la lista de vertices")
        return False
    
def mapa_aeropuertos():
    # Cargar la base de datos
    file_path = 'flights_final.csv'  # Cambia a la ruta de tu archivo
    datos = pd.read_csv(file_path)

    # Filtrar los datos de los aeropuertos únicos usando Source y Destination
    aeropuertos_origen = datos[['Source Airport Code', 'Source Airport Name', 'Source Airport City', 'Source Airport Country', 'Source Airport Latitude', 'Source Airport Longitude']]
    aeropuertos_destino = datos[['Destination Airport Code', 'Destination Airport Name', 'Destination Airport City', 'Destination Airport Country', 'Destination Airport Latitude', 'Destination Airport Longitude']]

    # Renombrar columnas para unir los dos DataFrames sin conflicto de nombres
    aeropuertos_origen.columns = ['Code', 'Name', 'City', 'Country', 'Latitude', 'Longitude']
    aeropuertos_destino.columns = ['Code', 'Name', 'City', 'Country', 'Latitude', 'Longitude']

    # Unir y eliminar duplicados
    aeropuertos = pd.concat([aeropuertos_origen, aeropuertos_destino]).drop_duplicates(subset=['Code'])

    # Crear el mapa centrado en una ubicación global promedio
    m = folium.Map(location=[0, 0], zoom_start=2)

    # Agregar marcadores para cada aeropuerto
    for _, row in aeropuertos.iterrows():
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['Name']} ({row['Code']}) - {row['City']}, {row['Country']}",
            icon=folium.Icon(color='blue', icon='plane', prefix='fa')
        ).add_to(m)

    # Guardar el mapa como un archivo HTML
    m.save("mapa_aeropuertos.html")

    print("Mapa generado y guardado como 'mapa_aeropuertos.html'")

def menu():
    print("-"*30)
    print("\nMENU")
    print("1. Imprimir informacion importante del grafo.")
    print("2. Imprimir informacion relacionada al bosque de expansion minima.")
    print("3. Imprimir informacion de un aeropuerto.")
    print("4. Calcular los 10 aeropuertos mas lejanos.")
    print("5. Calcular la distancia minima entre dos aeropuertos.")
    print("6. Mapa de Aeropuertos ")
    print("7. Salir")
    x=input("Ingrese la opcion deseada: ")
    print()
    while int(x) not in (1,2,3,4,5,6,7):
        x=input("Ingrese una opcion valida: ")
    return int(x)

def main():
    G,aristas,pesos= crear_grafo(codigos_origen, codigos_destino, vertices)
    edgesN=int( G.number_of_edges())
    componentes_conexas=list(nx.connected_components(G))


    opcion_menu=menu()
    if opcion_menu==1:
        print("Informacion importante del grafo:")
        print(f"Numero de vertices: {G.number_of_nodes()}")
        print(f"Numero de aristas: {G.number_of_edges()}")
        print(f"Numero de componentes conexas: {nx.number_connected_components(G)}")
        print("Numero de vertices por componente conexa:")
        print(len(componentes_conexas[0]), len(componentes_conexas[1]), len(componentes_conexas[2]), len(componentes_conexas[3]), len(componentes_conexas[4]), len(componentes_conexas[5]), len(componentes_conexas[6]))
        main()
    elif opcion_menu==2:
        bosques, peso_total, numedges = bosque_expansion_minima_manual(G)
        y=list(nx.connected_components(bosques))
        print(f"Número de árboles en el bosque de expansión mínima: {len(y)}")
        print(f"Peso total del bosque de expansión mínima: {peso_total}")
        print(f"Número de aristas en el bosque: {numedges}")
        print("\nPeso de cada arbol:")
        pesos_arboles = {}
        for idx, componente in enumerate(y):
            subgrafo = bosques.subgraph(componente)  # Obtener el subgrafo correspondiente a la componente
            peso_arbol = 0

            # Sumar los pesos de las aristas en el subgrafo
            for u, v, data in subgrafo.edges(data=True):
                peso_arbol += data['weight']

            pesos_arboles[idx] = peso_arbol  # Guardar el peso total de esta componente
        for idx, peso in pesos_arboles.items():
            print(f"Árbol {idx+1}: Peso total = {peso}\n")
        main()
    elif opcion_menu==3:
        codigo_aeropuerto = input("Ingrese el código del aeropuerto: ")
        while not validar_codigo(codigo_aeropuerto):
            codigo_aeropuerto = input("Ingrese el código del aeropuerto: ")
        mostrar_info_aeropuerto(codigo_aeropuerto)
        main()
    elif opcion_menu==4:
        codigo_aeropuerto = input("Ingrese el código del aeropuerto: ")
        while not validar_codigo(codigo_aeropuerto):
            codigo_aeropuerto = input("Ingrese el código del aeropuerto: ")

        aeropuertos_mas_lejanos(G, codigo_aeropuerto, datos)
        main()
    elif opcion_menu==5:
        cod_ori = input("\nDigite el código del aeropuerto de origen: ")
        while not validar_codigo(cod_ori):
            print("\nEl código ingresado no se encuentra en la lista de vértices")
            cod_ori = input("Digite el código del aeropuerto de origen: ")
        cod_des = input("\nDigite el código del aeropuerto de destino: ")
        while not validar_codigo(cod_des):
            print("\nEl código ingresado no se encuentra en la lista de vértices")
            cod_des = input("Digite el código del aeropuerto de destino: ")
        distancia_minima, predecesores=dijkstra_minima_distancia_entre_dos(G, cod_ori, cod_des)
        # Mostrar resultados
        if distancia_minima != math.inf:
            print(f"\nDistancia mínima entre {cod_ori} y {cod_des}: {distancia_minima:.2f} km")
            camino = reconstruir_camino(predecesores, cod_ori, cod_des)
            print(f"\nCamino más corto: {' -> '.join(camino)}\n")
            print("Datos:\n")
            for codigo in camino:
                mostrar_informacion_aeropuerto(codigo, datos)
            mapa_camino(G, camino)
        else:
            print(f"No hay un camino entre {cod_ori} y {cod_des}.")
        main()
    elif opcion_menu==6:
        mapa_aeropuertos()
        main()
    elif opcion_menu==7:
        print("Adios")
main()